---
layout: distill
title: Erwin Transformer
description: We can organize irregular data (point clouds, meshes) using ball trees to enable sub-quadratic (sparse) attention. Fast and expressive!
date: 2025-06-13
image: erwin.jpg
read_time: 10
tags: attention trees

paper_links:
  - name: "Code"
    url: "https://github.com/maxxxzdn/erwin"
  - name: "Paper" 
    url: "https://arxiv.org/abs/2502.17019"

toc:
  - name: Introduction
    subsections:
        - name: Sparse Attention on Irregular Data
        - name: Current Solutions in Physical Modelling
  - name: Tree-based Attention
    subsections:
        - name: Ball Trees
        - name: Capturing Long-range Interactions
        - name: Memory Layout of Erwin
        - name: Efficient Ball Tree implementation
  - name: Experiments
    subsections:
        - name: Molecular Dynamics
        - name: Standard PDE Benchmarks
        - name: Turbulent Fluid Dynamics
  - name: Future Work
    subsections:
        - name: Erwin Meets Native Sparse Attention
        - name: Erwin for Industrial Scale Applications
  - name: BibTeX
  - name: References

_styles: >
  .intro-gif {
      text-align: center;
      margin: 20px 0 40px 0;
  }
  .intro-gif video {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
  }

  d-article l-body b,
  d-article l-body strong,
  d-article b,
  d-article strong,
  l-body b,
  l-body strong,
  .l-body b,
  .l-body strong {
    font-weight: bold !important;
    color: inherit;
  }

  .content-section {
    max-width: 800px;
    margin: 40px auto;
    padding: 0 20px;
  }

  .section-title {
    font-size: 1.1em !important;
    font-weight: bold;
    text-align: center;
    margin-bottom: 30px;
    color: #333;
    line-height: 1.3;
  }

  .figure-container {
    width: 100%;
    display: flex;
    justify-content: center;
    margin: 30px 0;
  }

  .main-figure {
    width: 85%;
    max-width: 700px;
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .main-figure.half-width .responsive-image {
    width: 42.5%; /* Half of 85% */
    max-width: 350px;
  }

  .main-figure.three-quarter-width .responsive-image {
    width: 63.75%;
    max-width: 525px;
  }

  .main-figure.smaller-width .responsive-image {
    width: 76.5%;
    max-width: 630px;
  }

  /* Responsive image */
  .responsive-image {
    width: 100%;
    height: auto;
    margin-bottom: 15px;
    background: none;
    border: none;
  }

  .figure-caption {
    width: 100%;
    text-align: left;
    font-size: 1.00001em !important;
    line-height: 1.5;
    color: #555;
    margin-top: 15px;
    padding: 0 10px;
  }

  .figure-caption b, 
  .figure-caption strong {
    font-weight: bold !important;
    color: #333;
  }

  @media (max-width: 768px) {
    .content-section {
      padding: 0 15px;
      margin: 30px auto;
    }
    
    .section-title {
      font-size: 1.1em !important;
      margin-bottom: 25px;
    }
    
    .main-figure {
      width: 95%;
    }
    
    .figure-caption {
      font-size: 1.00001em !important;
      padding: 0 5px;
    }
  }

  @media (max-width: 480px) {
    .content-section {
      margin: 20px auto;
      padding: 0 10px;
    }
    
    .section-title {
      font-size: 1.0em !important;
      margin-bottom: 20px;
    }
    
    .main-figure {
      width: 100%;
    }
    
    .figure-caption {
      font-size: 1.00001em !important;
      margin-top: 12px;
    }
  }

---

<div class="intro-gif">
  <video controls loop muted playsinline preload="metadata" poster="{{ 'https://raw.githubusercontent.com/maxxxzdn/_erwin-visuals/main/kino_poster.jpg' | relative_url }}">
    <source src="{{ 'https://raw.githubusercontent.com/maxxxzdn/_erwin-visuals/main/kino.mp4' | relative_url }}" type="video/mp4" alt="Short video presentation of the paper." >
  </video>
</div>

## Introduction
Since attention<a href="#ref1">[1]</a> was introduced in 2017, a natural scientific instinct was to try to address its most obvious drawback - quadratic complexity. Many approaches emerged, specifically in the context of text and images. The main reason why numerous solutions exist for text and images is the regular structure of data. That is, if I tell you to look at position/column $j$, you know exactly where to look. Same with relative positions - there is no ambiguity when it comes to computing distance between two tokens in a sequence or two pixels in an image. Therefore, one can exploit this structure and derive a fixed attention pattern that is guaranteed to respect the geometry of the domain.

<div class="l-body">
  <div class="content-section">
    <h3 class="section-title">Sparse attention exploits locality in regular data</h3>
    <div class="figure-container">
      <figure class="main-figure">
        <img src="https://raw.githubusercontent.com/maxxxzdn/_erwin-visuals/main/sparse_attention.svg" 
             alt="Sparse attention patterns comparison" 
             class="responsive-image">
        <figcaption class="figure-caption">
        Sparse attention patterns reduce computational complexity by limiting which tokens can attend to each other.
        </figcaption>
      </figure>
    </div>
  </div>
</div>

### Sparse Attention on Irregular Data
Now, when it comes to irregular structures such as point clouds or unstructured meshes, the task becomes harder since data do not have an inherent ordering. This means that $i$-th and $j$-th elements are never guaranteed to be at the same distance from one another across different data points. As we cannot rely on regularity anymore, there is seemingly nothing to exploit - and the only solution would be to buckle up, make GPUs go brr and compute full attention. 

<div class="l-body">
  <div class="content-section">
    <h3 class="section-title">Sparse attention breaks locality in irregular data</h3>
    <div class="figure-container">
      <figure class="main-figure">
        <img src="https://raw.githubusercontent.com/maxxxzdn/_erwin-visuals/main/point_attention.svg" 
             alt="Point attention patterns comparison" 
             class="responsive-image">
        <figcaption class="figure-caption">
        Applied to unordered sets, sparse attention breaks down as spatial relationships are not preserved in the data ordering.
        </figcaption>
      </figure>
    </div>
  </div>
</div>

### Current Solutions in Physical Modelling
This solution is, however, unrealistic in physical modelling - the field I am interested in - for two reasons: A) all the GPUs are taken by LLM folks, B) the number of points might reach well beyond 1 million. Furthermore, there is clearly a need for sparse attention for large scale physical systems, despite the limited number of solutions available. The most popular approach so far involves pooling to latent tokens/supernodes (Transolver<a href="#ref2">[2]</a>, UPT<a href="#ref3">[3]</a>), which makes the total cost sub-linear. Alternatively, one can project irregular data onto a regular domain, as one has full control over the latent node arrangement. This was done in Aurora<a href="#ref4">[4]</a> (and later in Appa<a href="#ref5">[5]</a>), which first uses Perceiver<a href="#ref6">[6]</a> for projection and then Swin Transformer<a href="#ref7">[7]</a> for handling attention over the latent regular grid, thus bringing the complexity down to log-linear. In between, there are solutions that have linear complexity and are based on turning a point cloud into a 1D sequence, e.g., via tree traversal (Octformer<a href="#ref8">[8]</a>) or space-filling curves (PointTransformer v3<a href="#ref9">[9]</a>).

<div class="l-body">
  <div class="content-section">
    <h3 class="section-title">Sub-quadratic attention for irregular data</h3>
    <div class="figure-container">
      <figure class="main-figure smaller-width">
        <img src="https://raw.githubusercontent.com/maxxxzdn/_erwin-visuals/main/phys_attention.svg" 
             alt="Sub-quadratic attention for irregular data" 
             class="responsive-image">
        <figcaption class="figure-caption">
        Multiple solutions exist that avoid quadratic cost of attention by changing either data representation or data structure.
        </figcaption>
      </figure>
    </div>
  </div>
</div>

The advantage of the last approach is that it operates on native geometry and does not introduce an information bottleneck with pooling. Working with full fidelity is much closer in spirit to what people typically do in language modelling - the ultimate scaling frontier - with recent advancements in pushing the resolution even further with byte-level tokenization<a href="#ref10">[10]</a>. In general, I believe that this is what should be done at scale for as long as possible - let the data guide the model to decide which information to use and which not.

## Tree-based Attention
Therefore, the goal for the project was to find a solution that would allow operation on the original full-scale representation of a system, capture long-range interactions, but avoid quadratic scaling of full attention. This problem traces back to 1980s many-body physics, where physicists needed to simulate particle systems with long-range interactions (electrostatic/gravitational potentials) at the scale of tens of millions of nodes. To avoid computing all-to-all pairwise interactions ($\approx 10^{12}$ for 1M nodes), one can resort to approximations (e.g. [Barnes-Hut algorithm](https://arborjs.org/docs/barnes-hut)). Specifically, if there are many particles far away from a single node, one can treat those particles as a cluster and compute cluster-node interaction instead of pairwise interactions. This can be done at multiple scales, thus extending the range of captured interactions and their resolution. The computation is typically structured using hierarchical trees. For mode detils, check out the fantastic [blog by Andy Jones](https://andyljones.com/posts/multipole-methods.html) on the Fast Multipole Method, who also implemented it in PyTorch - well worth a read.

<div class="l-body">
  <div class="content-section">
   <h3 class="section-title">Many-body tree methods</h3>
    <div class="figure-container">
      <figure class="main-figure">
        <img src="https://raw.githubusercontent.com/maxxxzdn/_erwin-visuals/main/many_body_tree.svg" 
             alt="Hierarchical trees for many body problems" 
             class="responsive-image">
        <figcaption class="figure-caption">
        To avoid computing all pairwise interactions, a hierarchical tree is built on top a point cloud to guide when to compute an interaction directly, and when to approximate it.
        </figcaption>
      </figure>
    </div>
  </div>
</div>

This is the main idea behind Erwin - use hierarchical trees to impose regular structure on otherwise irregular data, then exploit this structure to organize attention and yield sub-quadratic complexity. Our first question was which tree to use. Traditionally, in many-body physics, octrees are used. These are built by recursively subdividing the cubic domain into sub-domains until each box contains at most a specified number of particles. This tree structure has even proved useful in the context of point cloud attention (see Octformer<a href="#ref8">[8]</a>, which traverses the tree to turn the underlying point cloud into a sequence suitable for sparse attention). However, we did not pursue octrees as the partitions they form might be highly unbalanced when particles cluster. This is particularly apparent when working with molecular dynamics, as shown in the figure below.

<div class="l-body">
  <div class="content-section">
    <h3 class="section-title">Data-driven domain partitioning with trees</h3>
    <div class="figure-container">
      <figure class="main-figure three-quarter-width">
        <img src="https://raw.githubusercontent.com/maxxxzdn/_erwin-visuals/main/octree_vs_btree.svg" 
             alt="Tree comparison" 
             class="responsive-image">
        <figcaption class="figure-caption">
        Examples of hierarchical trees with different partitioning strategies.
        </figcaption>
      </figure>
    </div>
  </div>
</div>

### Ball Trees
On the contrary, ball trees, which we chose in the end, do not have this issue and are generally more robust to varying densities (although definitely not perfect, as we will see in the experiments later). Intuitively, the algorithm takes a bunch of points and covers them with a ball. Then, half of the points are covered with a smaller ball, and the remaining half with another ball such that no point belongs to both balls. The procedure is repeated until the smallest balls contain at most two points. You can now see why we chose to work with ball trees: they do not require covering the entire domain, only the points themselves, and at each tree level, the nodes are (often) associated with the same scale. This, in our opinion, makes ball trees an excellent candidate for handling irregular data, and we can now look at how they can be used to organize attention.


<div class="l-body">
  <div class="content-section">
    <h3 class="section-title">Iterative construction of Ball Tree</h3>
    <div class="figure-container">
      <figure class="main-figure three-quarter-width">
        <img src="https://raw.githubusercontent.com/maxxxzdn/erwin/main/misc/ball_tree_animation.gif" 
             alt="Ball Tree Animation" 
             class="responsive-image"
             style="margin-top: -5% !important;">
        <figcaption class="figure-caption">
        Ball Tree is built on top of a point cloud by iteratively splitting ball partitions in half.
        </figcaption>
      </figure>
    </div>
  </div>
</div>

Having built a tree, we can now compute attention within the ball tree partitions. Specifically, one can choose the level of the tree and compute attention (<em>Ball Tree Attention</em>, BTA) within the balls in parallel. This is essentially block attention, but now each block is guaranteed to contain tokens that are close to each other in Euclidean space. This spatial locality is natural for physical systems where interactions typically decay with distance - nearby particles have stronger forces between them, and local features often exhibit spatial coherence. Therefore, by grouping neighbouring points together, BTA aligns with the intuition that the most important interactions are captured within each attention block. This is the attention mechanism we use to capture fine local details in data.

<div class="l-body">
  <div class="content-section">
    <h3 class="section-title">Attention is computed within ball partitions</h3>
    <div class="figure-container">
      <figure class="main-figure three-quarter-width">
        <img src="https://raw.githubusercontent.com/maxxxzdn/_erwin-visuals/main/bta.svg" 
             alt="Ball Tree Attention" 
             class="responsive-image">
        <figcaption class="figure-caption">
        Ball Tree Attention reduces complexity to linear by restricting attention to local partitions of fixed size.
        </figcaption>
      </figure>
    </div>
  </div>
</div>

### Capturing Long-range Interactions
Now, obviously, block attention comes with a huge drawback - tokens cannot propagate information outside of their own blocks. This, of course, is unacceptable - we want to capture long-range interactions and hence have to introduce a mechanism for information to flow from one ball to another. We were inspired by Swin Transformer, which follows a very similar principle (the name Erwin is itself an homage to Swin Transformer, shifted windows $\rightarrow$ rotated windows). Specifically, while Swin uses sliding windows - essentially fixing the data and shifting the grid - we adapt the trick to irregular data. Specifically, we rotate the point cloud and build a second tree, exploiting the fact that ball tree construction is not rotation invariant, hence the new partitions will cover different groupings of points. By alternating between these two configurations in consecutive layers, we achieve information propagation beyond the original partitions.

<div class="l-body">
  <div class="content-section">
    <h3 class="section-title">Alternating between ball trees</h3>
    <div class="figure-container">
      <figure class="main-figure three-quarter-width">
        <img src="https://raw.githubusercontent.com/maxxxzdn/_erwin-visuals/main/tree_rot_alt.svg" 
             alt="Alternating trees in Erwin" 
             class="responsive-image">
        <figcaption class="figure-caption">
        Signal from a single point travels from one partition to another by iterating between ball trees in different layers.
        </figcaption>
      </figure>
    </div>
  </div>
</div>

For large particle systems, however, this strategy still has limited receptive field and might be prone to problems arising in message passing - oversmoothing and oversquashing. Therefore, to capture very long-range interactions, we coarsen the tree and implement the model UNet-style. This is done trivially by simply pooling points in leaf balls to their center of mass, which halves the number of nodes. A nice property of ball trees is that the pooled nodes will still be contained in the original partitions all the way up to the root, hence we do not have to rebuild it.

<div class="l-body">
  <div class="content-section">
    <h3 class="section-title">Information propagation via coarsening</h3>
    <div class="figure-container">
      <figure class="main-figure three-quarter-width">
        <img src="https://raw.githubusercontent.com/maxxxzdn/_erwin-visuals/main/coarsening.svg" 
             alt="Coarsening" 
             class="responsive-image">
        <figcaption class="figure-caption">
        Signal from a single point travels from one partition to a distant one by coarsening the original points and computing attention over coarser nodes followed by unpooling.
        </figcaption>
      </figure>
    </div>
  </div>
</div>

### Memory Layout of Erwin
Perhaps the nicest property of ball trees is how they are stored in memory. The memory layout is contiguous and nested, meaning that smaller partitions within the same ball are stored next to each other. This makes all the operations related to tree handling extremely efficient: to build balls, you simply reshape the data tensor, and to pool, you simply call the mean operation. With the computational overhead minimized, it really boils down to the attention operation and tree building, both of which have to be optimized.

<div class="l-body">
  <div class="content-section">
    <h3 class="section-title">Ball tree is stored in memory contiguously</h3>
    <div class="figure-container">
      <figure class="main-figure">
        <img src="https://raw.githubusercontent.com/maxxxzdn/_erwin-visuals/main/mem_layout.svg" 
             alt="Memory layout in Erwin" 
             class="responsive-image">
        <figcaption class="figure-caption">
        The contiguous storage property, combined with the fixed size of balls at each level, enables efficient implementation through tensor operations.
        </figcaption>
      </figure>
    </div>
  </div>
</div>

### Efficient Ball Tree implementation
Luckily for us, there are plenty of extremely smart people working on the latter, so we focused on optimizing ball tree construction. Let's be honest, if we claimed that our sparse attention is faster than full attention, but it takes seconds to organize the data, no one would be impressed. So, to impress people, we had to rewrite the implementation of scikit-learn which, while very efficient due to being written in C, does not allow handling batches, i.e., you have to build a tree for each element sequentially. To overcome this limitation, we (with great help from Claude, frankly speaking) implemented the construction in C++ and OpenMP such that the construction is parallelized over CPU cores and we can handle batches all in parallel, even with different point cloud sizes within the batch. This greatly reduces the runtime by a factor of 6 to 20 depending on the size of point clouds:

<div class="l-body">
  <div class="content-section">
    <h4>Benchmarking Ball Tree construction</h4>
    <table style="width: 100%; border-collapse: collapse; font-size: 0.85em;">
      <thead>
        <tr style="border-bottom: 2px solid #333;">
          <th style="text-align: left; padding: 8px;">Implementation</th>
          <th style="text-align: center; padding: 8px;">1k nodes</th>
          <th style="text-align: center; padding: 8px;">2k nodes</th>
          <th style="text-align: center; padding: 8px;">4k nodes</th>
          <th style="text-align: center; padding: 8px;">8k nodes</th>
          <th style="text-align: center; padding: 8px;">16k nodes</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="padding: 4px 8px;">sklearn + joblib</td>
          <td style="text-align: center; padding: 4px 8px;">15.6 ms</td>
          <td style="text-align: center; padding: 4px 8px;">16.3 ms</td>
          <td style="text-align: center; padding: 4px 8px;">21.2 ms</td>
          <td style="text-align: center; padding: 4px 8px;">24.1 ms</td>
          <td style="text-align: center; padding: 4px 8px;">44.0 ms</td>
        </tr>
        <tr style="border-top: 1px solid #ddd;">
          <td style="padding: 4px 8px;">Ours</td>
          <td style="text-align: center; padding: 4px 8px;">0.32 ms</td>
          <td style="text-align: center; padding: 4px 8px;">0.73 ms</td>
          <td style="text-align: center; padding: 4px 8px;">1.54 ms</td>
          <td style="text-align: center; padding: 4px 8px;">3.26 ms</td>
          <td style="text-align: center; padding: 4px 8px;">6.98 ms</td>
        </tr>
        <tr>
          <td style="padding: 4px 8px;">Speed-up</td>
          <td style="text-align: center; padding: 4px 8px;">48.8×</td>
          <td style="text-align: center; padding: 4px 8px;">22.3×</td>
          <td style="text-align: center; padding: 4px 8px;">13.8×</td>
          <td style="text-align: center; padding: 4px 8px;">7.4×</td>
          <td style="text-align: center; padding: 4px 8px;">6.3×</td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

## Experiments

Now, for the fun part - experiments. Before we present tables with bold numbers, let's highlight some technical details about Erwin's key properties: efficiency and global receptive field. Tree building consistently accounts for only a minor fraction of total computation time and can be precomputed before training for static geometries. To address the most frequently asked question: yes, you need to rebuild the tree at each time step when points move, but this is manageable because (A) our optimized implementation is fast, and (B) all layers share the same tree, amortizing the construction cost.

<div class="l-body">
  <div class="content-section">
    <div class="figure-container">
      <figure class="main-figure">
        <img src="https://raw.githubusercontent.com/maxxxzdn/_erwin-visuals/main/scaling_and_rf.svg"
             alt="Scaling and receptive field" 
             class="responsive-image">
        <figcaption class="figure-caption">
          <b>Left</b>: Computational cost of Erwin. We split the total
          runtime into building a ball tree and running a model. The input
          is a batch of 16 point clouds, each of size n. We fit a power law
          which indicates close to linear scaling. <b>Right</b>: Receptive field
          of MPNN vs Erwin, \(N\) = 800. A node is in the receptive field
          if changing its features affects the target node's output. MPNN
          consists of 6 layers, each node connected to 16 nearest neighbours.
        </figcaption>
      </figure>
    </div>
  </div>
</div>

### Molecular Dynamics
When we first started the project, I had large molecular systems in mind as a primary application. So this is exactly where I started: with the dataset from Fu et al.<a href="#ref11">[11]</a>, which contains dynamics of relatively large (coarse-grained, CG) polypeptides. The goal is to predict forces acting on each CG bead. As the main baseline we chose MPNN, which after some tuning turned out to be very tough to beat. In hindsight, this is not surprising as the dataset doesn't have any charges, hence all the interactions are local. The experiment also confirmed to me just how good MPNNs are at picking up local interactions. In fact, we had to put a small MPNN before attention blocks to capture very fine local features - something that transformer alone wasn't able to do (I wrote a [recent thread](https://twitter.com/maxxxzdn/status/1918303348177899992) about this on Twitter). Nonetheless, Erwin does push the Pareto frontier, mainly because of how fast it is at the scale of this dataset.

<div class="l-body">
  <div class="content-section">
    <div class="figure-container">
      <figure class="main-figure smaller-width">
        <img src="https://raw.githubusercontent.com/maxxxzdn/_erwin-visuals/main/md.svg" 
             alt="Molecular dynamics experiment" 
             class="responsive-image">
        <figcaption class="figure-caption">
        Test negative log-likelihood (NLL) of the predicted acceleration distribution for the molecular dynamics task (averaged
        over 3 runs). The size of the markers reflects the number of parameters.
        </figcaption>
      </figure>
    </div>
  </div>
</div>

### Standard PDE Benchmarks
Next, we benchmarked on a couple of PDE-related datasets - ShapeNet and datasets that people refer to as standard PDE benchmarks (specifically the ones that are not on regular grids, hence no Navier-Stokes or Darcy flow). Erwin shows incredibly strong performance on the majority of tasks but, interestingly, it fails on Airfoil - something that must be related to the structure of the mesh, where the density of points is decreasing moving away from the geometric center. We think this creates ball partitions with radically different densities, which complicates training. That being said, we never had issues with other non-uniform meshes. Another interesting finding was on the ShapeNet car dataset, where the strongest performance was achieved by models that did not involve any sort of pooling. That is, Erwin following a flat transformer structure (no coarse-graining of the tree) demonstrates state-of-the-art performance (for a sparse transformer, at least). This contrasts with other baselines that do involve pooling: GNO, UPT, Transolver. We attribute this to the sensitivity of the task to resolution - apparently one needs to work at full fidelity to capture all the necessary details.

<div class="table-container l-body" style="display: flex; justify-content: space-between; gap: 40px; margin: 20px 0;">
  <div style="flex: 1;">
    <h4>Standard PDE benchmarks</h4>
    <table style="width: 100%; border-collapse: collapse; font-size: 0.85em;">
      <thead>
        <tr style="border-bottom: 2px solid #333;">
          <th style="text-align: left; padding: 8px;">Model</th>
          <th style="text-align: center; padding: 8px;">Elasticity</th>
          <th style="text-align: center; padding: 8px;">Plasticity</th>
          <th style="text-align: center; padding: 8px;">Airfoil</th>
          <th style="text-align: center; padding: 8px;">Pipe</th>
        </tr>
      </thead>
      <tbody>
        <tr><td style="padding: 4px 8px;">LNO</td><td style="text-align: center; padding: 4px 8px;">0.69</td><td style="text-align: center; padding: 4px 8px;">0.29</td><td style="text-align: center; padding: 4px 8px;">0.53</td><td style="text-align: center; padding: 4px 8px;">0.31</td></tr>
        <tr><td style="padding: 4px 8px;">Galerkin</td><td style="text-align: center; padding: 4px 8px;">2.40</td><td style="text-align: center; padding: 4px 8px;">1.20</td><td style="text-align: center; padding: 4px 8px;">1.18</td><td style="text-align: center; padding: 4px 8px;">0.98</td></tr>
        <tr><td style="padding: 4px 8px;">HT-Net</td><td style="text-align: center; padding: 4px 8px;">/</td><td style="text-align: center; padding: 4px 8px;">3.33</td><td style="text-align: center; padding: 4px 8px;">0.65</td><td style="text-align: center; padding: 4px 8px;">0.59</td></tr>
        <tr><td style="padding: 4px 8px;">OFormer</td><td style="text-align: center; padding: 4px 8px;">1.83</td><td style="text-align: center; padding: 4px 8px;">0.17</td><td style="text-align: center; padding: 4px 8px;">1.83</td><td style="text-align: center; padding: 4px 8px;">1.68</td></tr>
        <tr><td style="padding: 4px 8px;">GNOT</td><td style="text-align: center; padding: 4px 8px;">0.86</td><td style="text-align: center; padding: 4px 8px;">3.36</td><td style="text-align: center; padding: 4px 8px;">0.76</td><td style="text-align: center; padding: 4px 8px;">0.47</td></tr>
        <tr><td style="padding: 4px 8px;">FactFormer</td><td style="text-align: center; padding: 4px 8px;">/</td><td style="text-align: center; padding: 4px 8px;">3.12</td><td style="text-align: center; padding: 4px 8px;">0.71</td><td style="text-align: center; padding: 4px 8px;">0.60</td></tr>
        <tr><td style="padding: 4px 8px;">ONO</td><td style="text-align: center; padding: 4px 8px;">1.18</td><td style="text-align: center; padding: 4px 8px;">0.48</td><td style="text-align: center; padding: 4px 8px;">0.61</td><td style="text-align: center; padding: 4px 8px;">0.52</td></tr>
        <tr><td style="padding: 4px 8px;">Transolver++</td><td style="text-align: center; padding: 4px 8px;">0.52</td><td style="text-align: center; padding: 4px 8px;">0.11</td><td style="text-align: center; padding: 4px 8px;"><b>0.48</b></td><td style="text-align: center; padding: 4px 8px;"><b>0.27</b></td></tr>
        <tr style="border-top: 1px solid #ddd;"><td style="padding: 4px 8px;"><b>Erwin (Ours)</b></td><td style="text-align: center; padding: 4px 8px;"><b>0.34</b></td><td style="text-align: center; padding: 4px 8px;"><b>0.10</b></td><td style="text-align: center; padding: 4px 8px;">2.57</td><td style="text-align: center; padding: 4px 8px;">0.61</td></tr>
      </tbody>
    </table>
  </div>
  <div style="flex: 1;">
    <h4>ShapeNet-Car</h4>
    <table style="width: 100%; border-collapse: collapse; font-size: 0.85em;">
      <thead>
        <tr style="border-bottom: 2px solid #333;">
          <th style="text-align: left; padding: 8px;">Model</th>
          <th style="text-align: center; padding: 8px;">MSE</th>
        </tr>
      </thead>
      <tbody>
        <tr><td style="padding: 4px 8px;">PointNet</td><td style="text-align: center; padding: 4px 8px;">43.36</td></tr>
        <tr><td style="padding: 4px 8px;">GINO</td><td style="text-align: center; padding: 4px 8px;">35.24</td></tr>
        <tr><td style="padding: 4px 8px;">UPT</td><td style="text-align: center; padding: 4px 8px;">31.66</td></tr>
        <tr><td style="padding: 4px 8px;">Transolver</td><td style="text-align: center; padding: 4px 8px;">19.88</td></tr>
        <tr><td style="padding: 4px 8px;">GP-UPT</td><td style="text-align: center; padding: 4px 8px;">17.02</td></tr>
        <tr><td style="padding: 4px 8px;">PTV3-S</td><td style="text-align: center; padding: 4px 8px;">19.09</td></tr>
        <tr><td style="padding: 4px 8px;">PTV3-M</td><td style="text-align: center; padding: 4px 8px;">17.42</td></tr>
        <tr style="border-top: 1px solid #ddd;"><td style="padding: 4px 8px;"><b>Erwin-S (Ours)</b></td><td style="text-align: center; padding: 4px 8px;"><b>15.85</b></td></tr>
        <tr><td style="padding: 4px 8px;"><b>Erwin-M (Ours)</b></td><td style="text-align: center; padding: 4px 8px;"><b>15.43</b></td></tr>
      </tbody>
    </table>
  </div>
</div>

### Turbulent Fluid Dynamics

<div class="l-body">
  <div class="content-section">
    <div class="figure-container">
      <figure class="main-figure smaller-width">
        <img src="https://raw.githubusercontent.com/maxxxzdn/_erwin-visuals/main/eagle.svg" 
             alt="Turbulent fluid dynamics experiment" 
             class="responsive-image">
        <figcaption class="figure-caption">
        The norm of the velocity field at different steps of the rollout trajectories.
        </figcaption>
      </figure>
    </div>
  </div>
</div>

The final experiment is the EAGLE dataset<a href="#ref12">[12]</a>, which is a large-scale collection of turbulent fluid dynamics trajectories on irregular meshes of different shapes, approximately 3.5k nodes on average. There is nothing really interesting to say except for just how well a good model can learn and for how long it can unroll seemingly complex trajectories autoregressively. It was very impressive to see, and even better to see Erwin do it the best :).

<div class="l-body" style="margin: 20px 0;">
  <h4>RMSE on velocity V and pressure P fields across different prediction horizons</h4>
  <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
    <thead>
        <th rowspan="2" style="text-align: left; padding: 8px; border-right: 1px solid #ddd;">Model</th>
        <th colspan="2" style="text-align: center; padding: 8px; border-right: 1px solid #ddd;">\(+\Delta t \)</th>
        <th colspan="2" style="text-align: center; padding: 8px; border-right: 1px solid #ddd;">\(+50\Delta t \)</th>
        <th rowspan="2" style="text-align: center; padding: 8px; border-right: 1px solid #ddd;">Time<br/>(ms)</th>
        <th rowspan="2" style="text-align: center; padding: 8px;">Mem.<br/>(GB)</th>
      <tr style="border-bottom: 2px solid #333;">
        <th style="text-align: center; padding: 8px;">V</th>
        <th style="text-align: center; padding: 8px; border-right: 1px solid #ddd;">P</th>
        <th style="text-align: center; padding: 8px;">V</th>
        <th style="text-align: center; padding: 8px; border-right: 1px solid #ddd;">P</th>
      </tr>
    </thead>
    <tbody>
      <tr><td style="padding: 4px 8px;">MGN</td><td style="text-align: center; padding: 4px 8px;">0.081</td><td style="text-align: center; padding: 4px 8px; border-right: 1px solid #ddd;">0.43</td><td style="text-align: center; padding: 4px 8px;">0.592</td><td style="text-align: center; padding: 4px 8px; border-right: 1px solid #ddd;">2.25</td><td style="text-align: center; padding: 4px 8px; border-right: 1px solid #ddd;">40</td><td style="text-align: center; padding: 4px 8px;">0.7</td></tr>
      <tr><td style="padding: 4px 8px;">GAT</td><td style="text-align: center; padding: 4px 8px;">0.170</td><td style="text-align: center; padding: 4px 8px; border-right: 1px solid #ddd;">64.6</td><td style="text-align: center; padding: 4px 8px;">0.855</td><td style="text-align: center; padding: 4px 8px; border-right: 1px solid #ddd;">163</td><td style="text-align: center; padding: 4px 8px; border-right: 1px solid #ddd;">44</td><td style="text-align: center; padding: 4px 8px;">0.5</td></tr>
      <tr><td style="padding: 4px 8px;">DRN</td><td style="text-align: center; padding: 4px 8px;">0.251</td><td style="text-align: center; padding: 4px 8px; border-right: 1px solid #ddd;">1.45</td><td style="text-align: center; padding: 4px 8px;">0.537</td><td style="text-align: center; padding: 4px 8px; border-right: 1px solid #ddd;">2.46</td><td style="text-align: center; padding: 4px 8px; border-right: 1px solid #ddd;">42</td><td style="text-align: center; padding: 4px 8px;"><b>0.2</b></td></tr>
      <tr><td style="padding: 4px 8px;">EAGLE</td><td style="text-align: center; padding: 4px 8px;">0.053</td><td style="text-align: center; padding: 4px 8px; border-right: 1px solid #ddd;">0.46</td><td style="text-align: center; padding: 4px 8px;">0.349</td><td style="text-align: center; padding: 4px 8px; border-right: 1px solid #ddd;">1.44</td><td style="text-align: center; padding: 4px 8px; border-right: 1px solid #ddd;">30</td><td style="text-align: center; padding: 4px 8px;">1.5</td></tr>
      <tr style="border-top: 1px solid #ddd;"><td style="padding: 4px 8px;"><b>Erwin<br/>(Ours)</b></td><td style="text-align: center; padding: 4px 8px;"><b>0.044<br/>±0.001</b></td><td style="text-align: center; padding: 4px 8px; border-right: 1px solid #ddd;"><b>0.31<br/>±0.01</b></td><td style="text-align: center; padding: 4px 8px;"><b>0.281<br/>±0.001</b></td><td style="text-align: center; padding: 4px 8px; border-right: 1px solid #ddd;"><b>1.15<br/>±0.06</b></td><td style="text-align: center; padding: 4px 8px; border-right: 1px solid #ddd;"><b>11</b></td><td style="text-align: center; padding: 4px 8px;"><b>0.2</b></td></tr>
    </tbody>
  </table>
</div>

## Future Work

Regarding future work, there are definitely exciting directions to explore given how simple and even trivial the current attention pattern is, and how much more can be done by exploiting the ball tree structure to make the model more expressive. Below are two projects that I am working on with my students.

### Erwin Meets Native Sparse Attention

<div class="l-body">
  <div class="content-section">
    <div class="figure-container">
      <figure class="main-figure smaller-width">
        <img src="https://raw.githubusercontent.com/maxxxzdn/_erwin-visuals/main/bsa.svg" 
             alt="BSA" 
             class="responsive-image">
        <figcaption class="figure-caption">
        Ball Sparse Attention (BSA). A ball tree imposes spatial locality, then three sparse-attention branches—grouping (block clustering), compression (MLP-based token pooling), and selection (top-k block retrieval) operate alongside fine-grained ball attention. A learnable gate fuses their outputs into the final attention.
        </figcaption>
      </figure>
    </div>
  </div>
</div>

To improve the processing of long-range informaition while keeping the cost sub-quadratic, we combine the ball tree with Native Sparse Attention (NSA) from DeepSeek, which align naturally with each other. Specifically, NSA allows Erwin to learn for each leaf node to which partitions to attend in the tree in a data-driven manner, thus extending interactions beyond fixed balls. We already have some promising results that I will be presenting at ICML 2025 Workshop on Long-Context Foundation Models, see [the paper](https://arxiv.org/abs/2506.12541) and [the code](https://github.com/britacatalin/bsa).

### Erwin for Industrial Scale Applications

<div class="l-body">
  <div class="content-section">
    <div class="figure-container">
      <figure class="main-figure smaller-width">
        <img src="https://raw.githubusercontent.com/maxxxzdn/_erwin-visuals/main/haet.jpg" 
             alt="HAET" 
             class="responsive-image">
        <figcaption class="figure-caption">
        To process industrial scale systems, we use the slicing approach of Transolver and then process them with Ball Tree attention.
        </figcaption>
      </figure>
    </div>
  </div>
</div>

Despite its linear complexity, applications involving simulations with tens of millions of particles currently remain beyond Erwin's reach. To address this, we are exploring a hybrid approach: combining Transolver with Erwin by applying ball tree attention over latent tokens. The key insight is that by using Erwin to process these supernodes, we can afford larger bottleneck sizes (more supernodes) while maintaining efficiency. This allows us to significantly reduce the compression ratio compared to Transolver, preserving more information while keeping computational costs manageable. [Initial results](https://github.com/pedrocurvo/HAET) are promising - stay tuned!

## BibTeX
If you find our work relevant to your research or found it otherwise useful, please consider citing us :)
```
@inproceedings{zhdanov2025erwin,
    title={Erwin: A Tree-based Hierarchical Transformer for Large-scale Physical Systems}, 
    author={Maksim Zhdanov and Max Welling and Jan-Willem van de Meent},
    booktitle = {International {Conference} on {Machine} {Learning} ({ICML})},
    year = {2025},
}
```

## References

<div id="ref1">[1] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, Illia Polosukhin. <strong>Attention is All you Need.</strong> <em>NIPS 2017</em></div>

<div id="ref2">[2] Haixu Wu, Huakun Luo, Haowen Wang, Jianmin Wang, Mingsheng Long. <strong>Transolver: A Fast Transformer Solver for PDEs on General Geometries.</strong> <em>ICML 2024</em></div>

<div id="ref3">[3] Benedikt Alkin, Andreas Fürst, Simon Schmid, Lukas Gruber, Markus Holzleitner, Johannes Brandstetter. <strong>Universal Physics Transformers: A Framework For Efficiently Scaling Neural Operators.</strong> <em>NeurIPS 2024</em></div>

<div id="ref4">[4] Cristian Bodnar, Wessel P. Bruinsma, Ana Lucic, Megan Stanley, Anna Allen, Johannes Brandstetter, Patrick Garvan, Maik Riechert, Jonathan A. Weyn, Haiyu Dong, Jayesh K. Gupta, Kit Thambiratnam, Alexander T. Archibald, Chun-Chieh Wu, Elizabeth Heider, Max Welling, Richard E. Turner, Paris Perdikaris. <strong>A foundation model for the Earth system.</strong> <em>Nature 641(8065): 1180-1187 (2025)</em></div>

<div id="ref5">[5] Gérôme Andry, François Rozet, Sacha Lewin, Omer Rochman Sharabi, Victor Mangeleer, Matthias Pirlet, Elise Faulx, Marilaure Grégoire, Gilles Louppe. <strong>Appa: Bending Weather Dynamics with Latent Diffusion Models for Global Data Assimilation.</strong> <em>CoRR abs/2504.18720 (2025)</em></div>

<div id="ref6">[6] Andrew Jaegle, Felix Gimeno, Andy Brock, Oriol Vinyals, Andrew Zisserman, João Carreira. <strong>Perceiver: General Perception with Iterative Attention.</strong> <em>ICML 2021</em></div>

<div id="ref7">[7] Ze Liu, Yutong Lin, Yue Cao, Han Hu, Yixuan Wei, Zheng Zhang, Stephen Lin, Baining Guo. <strong>Swin Transformer: Hierarchical Vision Transformer using Shifted Windows.</strong> <em>ICCV 2021</em></div>

<div id="ref8">[8] Peng-Shuai Wang. <strong>OctFormer: Octree-based Transformers for 3D Point Clouds.</strong> <em>SIGGRAPH 2023</em></div>

<div id="ref9">[9] Xiaoyang Wu, Li Jiang, Peng-Shuai Wang, Zhijian Liu, Xihui Liu, Yu Qiao, Wanli Ouyang, Tong He, Hengshuang Zhao. <strong>Point Transformer V3: Simpler, Faster, Stronger.</strong> <em>CVPR 2024</em></div>

<div id="ref10">[10] Artidoro Pagnoni, Ram Pasunuru, Pedro Rodríguez, John Nguyen, Benjamin Muller, Margaret Li, Chunting Zhou, Lili Yu, Jason Weston, Luke Zettlemoyer, Gargi Ghosh, Mike Lewis, Ari Holtzman, Srinivasan Iyer. <strong>Byte Latent Transformer: Patches Scale Better Than Tokens.</strong> <em>CoRR abs/2412.09871 (2024)</em></div>

<div id="ref11">[11] Xiang Fu, Tian Xie, Nathan J. Rebello, Bradley D. Olsen, Tommi S. Jaakkola. <strong>Simulate Time-integrated Coarse-grained Molecular Dynamics with Multi-scale Graph Networks.</strong> <em>Trans. Mach. Learn. Res. 2023 (2023)</em></div>

<div id="ref12">[12] Steeven Janny, Aurélien Béneteau, Madiha Nadri, Julie Digne, Nicolas Thome, Christian Wolf. <strong>EAGLE: Large-scale Learning of Turbulent Fluid Dynamics with Mesh Transformers.</strong> <em>ICLR 2023</em></div>